import {
  app,
  BrowserWindow,
  ipcMain,
  desktopCapturer,
  screen,
  nativeImage,
  dialog,
} from "electron";
import path from "path"; // Import path module
import fs from "fs"; // <-- Import fs
// Import our new capture service - add after the other imports
import * as captureService from "./services/captureService";
// Import the manual settings store
import * as settingsStore from "./manualSettingsStore";
import type { AppSettings } from "./types"; // Corrected import

console.log("[index.ts] Starting main process execution..."); // <-- ADD LOG

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
// Declare the entry point for the capture window
declare const CAPTURE_WINDOW_WEBPACK_ENTRY: string;
declare const CAPTURE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
// Declare entry points for Hub windows (as defined in forge.config.ts)
declare const HUB_MENU_WINDOW_WEBPACK_ENTRY: string;
declare const HUB_MENU_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
// NOTE: HUB_TRIGGER_WINDOW_WEBPACK_ENTRY is not needed as it loads an HTML file directly
// declare const HUB_TRIGGER_WINDOW_PRELOAD_WEBPACK_ENTRY: string; // Preload constant for trigger is unreliable

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  console.log("[index.ts] Electron Squirrel startup detected. Quitting."); // <-- ADD LOG
  app.quit();
}

console.log("[index.ts] Passed Squirrel check. Proceeding..."); // <-- ADD LOG

// --- Single Instance Lock ---
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  console.log("[index.ts] Did not acquire single instance lock. Quitting.");
  app.quit();
} else {
  app.on("second-instance", (event, commandLine, workingDirectory) => {
    // Someone tried to run a second instance, we should focus our window.
    console.log("[index.ts] Second instance detected. Focusing main window.");
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  // Create mainWindow, load the rest of the app, etc...
  // This is where your existing app initialization logic will continue.
  console.log("[index.ts] Acquired single instance lock. Starting app.");
}
// --- End Single Instance Lock ---

console.log("[index.ts] Defining global variables..."); // <-- ADD LOG
// Keep track of the main window globally (or pass it around)
export let mainWindow: BrowserWindow | null = null;
// Temporary state for region capture
let captureWindow: BrowserWindow | null = null;
let tempScreenshotDataUrl: string | null = null;
// --- Moved Hub window references here ---
let menuWindow: BrowserWindow | null = null;
let triggerWindow: BrowserWindow | null = null;
let menuTargetX: number | null = null; // Variable to store the calculated X position
// --- End Hub window references ---

// --- Hub Helper Functions ---
const HUB_WIDTH = 620; // Increased to accommodate padding
const HUB_HEIGHT = 620;

const getAssetPath = (...paths: string[]): string => {
  return app.isPackaged
    ? path.join(process.resourcesPath, "app", ...paths)
    : path.join(app.getAppPath(), ...paths);
};

// --- Function to Register ALL IPC Handlers ---
function registerIpcHandlers() {
  console.log("[index.ts] Registering IPC Handlers START"); // <-- ADD LOG
  // Settings Handlers
  ipcMain.handle("get-settings", async (): Promise<AppSettings> => {
    console.log("IPC: Handling get-settings");
    return settingsStore.getSettings();
  });
  ipcMain.handle(
    "save-settings",
    async (event, newSettings: Partial<AppSettings>) => {
      console.log("IPC: Handling save-settings", newSettings);
      settingsStore.saveSettings(newSettings);
      return { success: true };
    }
  );
  ipcMain.handle("reset-settings", async (): Promise<AppSettings> => {
    console.log("IPC: Handling reset-settings");
    return settingsStore.resetSettings();
  });

  // Capture Handlers (Keep existing implementations)
  ipcMain.handle("capture", async (event, type: string, options?: any) => {
    console.log(`[index.ts] Received 'capture' IPC message. Type: ${type}`);
    // Prevent concurrent captures
    if (captureWindow) {
      return { success: false, message: "Capture already in progress" };
    }

    try {
      if (type === "fullscreen") {
        console.log("Handling fullscreen capture via captureService...");

        let captureResult;
        if (mainWindow && mainWindow.isVisible()) {
          console.log(
            "[capture handler] Hiding main window for fullscreen capture."
          );
          mainWindow.hide();
          // Add a small delay to ensure window is hidden before capture
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        try {
          captureResult = await captureService.captureFullScreen();
        } finally {
          if (mainWindow && !mainWindow.isDestroyed()) {
            console.log(
              "[capture handler] Showing main window after fullscreen capture attempt."
            );
            mainWindow.show();
            mainWindow.focus();
            mainWindow.moveTop();
          }
        }
        return captureResult;
      } else if (type === "region") {
        console.log("Handling region capture...");
        if (!mainWindow)
          return { success: false, message: "Main window not available" };

        // --- Start Operations Concurrently ---

        // 1. Start Screenshot Capture Promise
        const screenshotPromise = (async () => {
          const primaryDisplay = screen.getPrimaryDisplay();
          const { width, height } = primaryDisplay.size;
          const scaleFactor = primaryDisplay.scaleFactor;
          const sources = await desktopCapturer.getSources({
            types: ["screen"],
            thumbnailSize: {
              width: width * scaleFactor,
              height: height * scaleFactor,
            },
          });
          const primarySource = sources.find(
            (source) =>
              source.display_id?.toString() === primaryDisplay.id.toString()
          );
          if (!primarySource) {
            throw new Error(
              "Primary display source not found for region capture."
            );
          }
          // Store screenshot temporarily (make sure tempScreenshotDataUrl is accessible)
          tempScreenshotDataUrl = primarySource.thumbnail.toDataURL();
          console.log("Screenshot captured.");
          return tempScreenshotDataUrl; // Return data URL or just signal completion
        })();

        // 2. Start Window Creation and Loading Promise
        const windowReadyPromise = new Promise<void>((resolve, reject) => {
          const primaryDisplay = screen.getPrimaryDisplay(); // Get display info again
          const { width, height } = primaryDisplay.size;

          // Create the capture window
          captureWindow = new BrowserWindow({
            x: primaryDisplay.bounds.x,
            y: primaryDisplay.bounds.y,
            width: width,
            height: height,
            frame: false,
            alwaysOnTop: true,
            skipTaskbar: true,
            autoHideMenuBar: true,
            show: false, // Start hidden, show when ready
            webPreferences: {
              preload: CAPTURE_WINDOW_PRELOAD_WEBPACK_ENTRY,
            },
          });
          console.log("Capture window created.");

          // Resolve promise when content finishes loading
          captureWindow.webContents.once("did-finish-load", () => {
            console.log("Capture window finished loading.");
            if (captureWindow && !captureWindow.isDestroyed()) {
              captureWindow.show(); // Show the window now that it's loaded
              resolve(); // Signal that the window is ready
            } else {
              reject(
                new Error("Capture window destroyed before load finished.")
              );
            }
          });

          // Load the base capture UI URL
          const captureUrl = CAPTURE_WINDOW_WEBPACK_ENTRY;
          console.log(`Loading capture window URL: ${captureUrl}`);
          captureWindow.loadURL(captureUrl);

          // Open DevTools (optional, can be removed later)
          // Remove automatic DevTools opening for capture window
          // captureWindow.webContents.openDevTools();
        });

        // --- Wait for Both Operations ---
        console.log("Waiting for screenshot capture and window load...");
        await Promise.all([screenshotPromise, windowReadyPromise]);
        console.log("Both operations complete.");

        // --- Send Data to Ready Window ---
        if (
          captureWindow &&
          !captureWindow.isDestroyed() &&
          tempScreenshotDataUrl
        ) {
          console.log("Sending screenshot data via IPC...");
          captureWindow.webContents.send(
            "screenshot-data",
            tempScreenshotDataUrl
          );
        } else {
          // Should not happen if promises resolved, but handle defensively
          console.error("Window or screenshot data missing after waiting.");
          cleanupCapture(); // Clean up if something went wrong
          throw new Error("Failed to prepare capture window or data.");
        }

        // Return success for initiation, final result comes via 'capture-result'
        return { success: true, message: "Region capture window opened" };
      } else if (type === "window") {
        console.log("Handling window capture...");
        if (!options?.windowId) {
          return { success: false, message: "Window ID missing for capture." };
        }
        const windowId = options.windowId;
        console.log(`Attempting to capture window ID: ${windowId}`);

        let dataUrl: string | null = null;
        let errorOccurred = false;
        let errorMessage = "Failed to capture selected window.";

        // Optionally hide main window (might help focus or prevent capturing itself)
        // if (mainWindow && mainWindow.isVisible()) {
        //   mainWindow.hide();
        //   await new Promise(resolve => setTimeout(resolve, 50));
        // }

        try {
          // Use the captureService for the core logic now
          const result = await captureService.captureWindow(windowId);
          if (result.success && result.dataUrl) {
            dataUrl = result.dataUrl;
            console.log("Window capture successful (thumbnail obtained).");
          } else {
            throw new Error(result.message || "Failed to capture window");
          }
        } catch (captureError) {
          console.error("Error during window capture process:", captureError);
          errorOccurred = true;
          // Try to detect WGC error specifically
          if (
            captureError.message &&
            captureError.message.includes("Source is not capturable")
          ) {
            errorMessage =
              "Selected window cannot be captured (it might be protected, minimized, or incompatible).";
          } else if (captureError.message) {
            errorMessage = captureError.message;
          } else {
            errorMessage = "An unknown error occurred during window capture.";
          }
          // No need to re-throw, we handle the return below
        } finally {
          // Show main window again if it was hidden
          // if (mainWindow && !mainWindow.isVisible() && !mainWindow.isDestroyed()) {
          //   mainWindow.show();
          //   mainWindow.focus();
          // }
        }

        if (!errorOccurred && dataUrl) {
          // Send data back directly in the handle response
          return { success: true, dataUrl };
        } else {
          return { success: false, message: errorMessage };
        }
      } else {
        console.warn(`Unknown capture type: ${type}`);
        return { success: false, message: "Unknown capture type" };
      }
    } catch (error) {
      console.error("Capture Initiation Error:", error);
      cleanupCapture(); // Clean up if initiation failed
      return {
        success: false,
        message: error.message || "An unknown capture error occurred",
      };
    }
  });

  // *** IPC listener for capture results from captureWindow ***
  ipcMain.on(
    "capture-result",
    async (event, result: { cancelled: boolean; bounds?: any }) => {
      console.log("Received capture result:", result);

      const storedScreenshotUrl = tempScreenshotDataUrl; // Copy potential data
      const mainWin = mainWindow; // Copy potential main window
      let needsCleanup = true; // Assume cleanup is needed unless successful

      // --- Don't cleanup immediately ---

      if (
        result.cancelled ||
        !result.bounds ||
        !storedScreenshotUrl ||
        !mainWin
      ) {
        console.log("Region capture cancelled or failed.");
        // cleanupCapture(); // Cleanup handled later or in error block
        // --->>> ADD Show Main Window on Cancel/Fail <<<---
        if (mainWin && !mainWin.isDestroyed()) {
          console.log(
            "Showing main window after cancelled/failed region capture."
          );
          mainWin.show();
          mainWin.focus();
          mainWin.moveTop(); // <<< ADDED: Bring to front
        }
        cleanupCapture(); // Cleanup now
        // --- End Show ---
        return; // Nothing more to do
      }

      try {
        // Get scale factor for accurate cropping
        const primaryDisplay = screen.getPrimaryDisplay();
        const scaleFactor = primaryDisplay.scaleFactor;

        // Adjust bounds for scale factor
        const scaledBounds = {
          x: Math.floor(result.bounds.x * scaleFactor),
          y: Math.floor(result.bounds.y * scaleFactor),
          width: Math.floor(result.bounds.width * scaleFactor),
          height: Math.floor(result.bounds.height * scaleFactor),
        };

        // Ensure bounds are within image dimensions (basic check)
        const image = nativeImage.createFromDataURL(storedScreenshotUrl);
        const imageSize = image.getSize();
        if (scaledBounds.x < 0) scaledBounds.x = 0;
        if (scaledBounds.y < 0) scaledBounds.y = 0;
        if (scaledBounds.x + scaledBounds.width > imageSize.width)
          scaledBounds.width = imageSize.width - scaledBounds.x;
        if (scaledBounds.y + scaledBounds.height > imageSize.height)
          scaledBounds.height = imageSize.height - scaledBounds.y;
        if (scaledBounds.width <= 0 || scaledBounds.height <= 0) {
          throw new Error("Calculated crop bounds are invalid.");
        }

        // Crop the image
        const croppedImage = image.crop(scaledBounds);
        const croppedDataUrl = croppedImage.toDataURL();

        // --->>> ADD Log before sending data <<<---
        console.log(
          "[capture-result] Sending final cropped region dataUrl to main window."
        );
        // --->>> End Log <<<---

        // Send the final cropped image back to the main window renderer
        mainWin.webContents.send("capture-data", {
          success: true,
          dataUrl: croppedDataUrl,
        });
        needsCleanup = false; // Success! Mark cleanup as done after showing window

        // --->>> MOVED/MODIFIED: Show the main window now that it has data <<<---
        if (mainWin && !mainWin.isDestroyed()) {
          mainWin.show();
          mainWin.focus();
          mainWin.moveTop(); // <<< ADDED: Bring to front
          console.log("Main window shown after successful region capture.");
        }
        // --- End MOVED/MODIFIED ---

        // --- Cleanup AFTER sending data and showing window ---
        cleanupCapture(); // <-- MOVE CLEANUP HERE
      } catch (error) {
        console.error("Error processing region capture result:", error);
        // Optionally send an error message back to the main window
        if (mainWin && !mainWin.isDestroyed()) {
          mainWin.webContents.send("capture-data", {
            success: false,
            message: error.message,
          });
          // --->>> ADD Show Main Window on Error <<<---
          console.log(
            "Showing main window after error during region processing."
          );
          mainWin.show();
          mainWin.focus();
          mainWin.moveTop(); // <<< ADDED: Bring to front
          // --- End Show ---
        }
        // --- Cleanup on error ---
        if (needsCleanup) {
          // Only cleanup if not already done
          cleanupCapture(); // <-- ADD CLEANUP HERE
        }
      }
    }
  );

  // Listener for quit request from renderer
  ipcMain.on("quit-app", () => {
    console.log(
      "Quit request received from renderer. Closing main window only (keeping hub menu active)."
    );
    // Only close the main window, keep hub windows running
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log("Closing main window...");
      mainWindow.close();
      mainWindow = null; // Clear the reference
    }
    // Do NOT call app.quit() - let the hub menu system continue running
    console.log("Main window closed. Hub menu system remains active.");
  });

  // --- Video Recording IPC Handlers ---
  ipcMain.handle("get-screen-sources", async () => {
    console.log("Received request for screen sources.");
    try {
      // Get primary display ID *here* in the main process
      const primaryDisplayId = screen.getPrimaryDisplay().id.toString();

      const sources = await desktopCapturer.getSources({
        types: ["window", "screen"],
      });
      console.log(`Found ${sources.length} sources.`);

      // Map sources and add a flag for the primary display
      const mappedSources = sources.map((source) => ({
        ...source,
        isPrimary:
          source.display_id === primaryDisplayId &&
          source.name.toLowerCase().includes("screen"),
      }));

      // Filter out the main application window if desired (optional)
      // mappedSources = mappedSources.filter(source => source.name !== 'productivity-tool');

      return mappedSources; // Return the modified sources with the primary flag
    } catch (error) {
      console.error("Error getting screen sources:", error);
      return []; // Return empty array on error
    }
  });

  // Handle request to save recorded video
  ipcMain.handle("save-video", async (event, videoBuffer: ArrayBuffer) => {
    console.log("Received request to save video.");
    if (!mainWindow) {
      console.error("Main window not available for saving video.");
      return {
        success: false,
        error: "Main window not found.",
      };
    }
    if (!videoBuffer || videoBuffer.byteLength === 0) {
      console.error("Received empty video buffer.");
      return {
        success: false,
        error: "Video data is empty.",
      };
    }

    try {
      const buffer = Buffer.from(videoBuffer); // Convert ArrayBuffer to Node Buffer

      const { canceled, filePath } = await dialog.showSaveDialog(
        mainWindow, // Associate with the main window
        {
          buttonLabel: "Save video",
          defaultPath: `recording-${Date.now()}.webm`, // Default filename
          filters: [
            { name: "WebM Videos", extensions: ["webm"] },
            { name: "All Files", extensions: ["*"] },
          ],
        }
      );

      if (canceled || !filePath) {
        console.log("Video save cancelled by user.");
        return { success: false, error: "Save cancelled." };
      }

      console.log(`Saving video to: ${filePath}`);
      await fs.promises.writeFile(filePath, buffer);
      console.log("Video saved successfully.");

      // Send confirmation back via separate channel if needed, or just return success
      // mainWindow.webContents.send('save-complete', { success: true, filePath }); // Using return value now
      return { success: true, filePath };
    } catch (error) {
      console.error("Error saving video:", error);
      // mainWindow.webContents.send('save-complete', { success: false, error: error.message }); // Using return value now
      return {
        success: false,
        error: error.message || "Failed to save video.",
      };
    }
  });

  // --- Save As Image Handler ---
  ipcMain.handle("save-image-as", async (event, imageDataUrl: string) => {
    console.log("Received request to save image.");
    if (!mainWindow) {
      console.error("Main window not available for saving image.");
      return {
        success: false,
        error: "Main window not found.",
      };
    }
    if (!imageDataUrl) {
      console.error("Received empty image data URL.");
      return {
        success: false,
        error: "Image data is empty.",
      };
    }

    try {
      const { canceled, filePath } = await dialog.showSaveDialog(mainWindow, {
        buttonLabel: "Save Image",
        defaultPath: `screenshot-${Date.now()}.png`, // Default to PNG
        filters: [
          { name: "PNG Image", extensions: ["png"] },
          { name: "JPEG Image", extensions: ["jpg", "jpeg"] },
          { name: "All Files", extensions: ["*"] },
        ],
      });

      if (canceled || !filePath) {
        console.log("Image save cancelled by user.");
        return { success: false, error: "Save cancelled." };
      }

      console.log(`Saving image to: ${filePath}`);

      // Create native image from data URL
      const image = nativeImage.createFromDataURL(imageDataUrl);

      // Determine format and save
      let imageDataBuffer: Buffer;
      const fileExtension = path.extname(filePath).toLowerCase();

      if (fileExtension === ".jpg" || fileExtension === ".jpeg") {
        // Save as JPEG (quality 90)
        imageDataBuffer = image.toJPEG(90);
        console.log("Saving as JPEG.");
      } else {
        // Default to PNG
        imageDataBuffer = image.toPNG();
        console.log("Saving as PNG.");
      }

      await fs.promises.writeFile(filePath, imageDataBuffer);
      console.log("Image saved successfully.");

      return { success: true, filePath };
    } catch (error) {
      console.error("Error saving image:", error);
      return {
        success: false,
        error: error.message || "Failed to save image.",
      };
    }
  });

  // --- Window Visibility Handlers ---
  ipcMain.on("hide-main-window", () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log("Hiding main window.");
      mainWindow.hide();
    }
  });

  ipcMain.on("show-main-window", () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      // Optional: Add a small delay before showing if needed, e.g., after capture starts
      // setTimeout(() => { mainWindow.show(); }, 100); // Example delay
      console.log("Showing main window.");
      mainWindow.show();
    }
  });

  ipcMain.on("focus-main-window", () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log("Focusing main window for text editing.");
      mainWindow.focus();
      mainWindow.moveTop();
    }
  });

  // --- Window Capture Handlers ---
  ipcMain.handle("get-window-sources", async () => {
    console.log("[IPC] Handling get-window-sources"); // <-- ADD LOG
    try {
      const sources = await captureService.getWindowSources();
      console.log(`[IPC] get-window-sources found ${sources.length} sources.`); // <-- ADD LOG
      return sources;
    } catch (error) {
      console.error("[IPC] Error in get-window-sources handler:", error); // <-- ADD LOG
      return [];
    }
  });

  ipcMain.handle("capture-window", async (event, windowId: string) => {
    console.log(`[IPC] Handling capture-window for ID: ${windowId}`); // <-- ADD LOG
    const mainWin = mainWindow; // Get mainWindow reference
    try {
      console.log(`Handling window capture for windowId: ${windowId}`);
      if (!windowId) {
        console.error("[IPC] capture-window called with no windowId."); // <-- ADD LOG
        return { success: false, message: "No window ID provided" };
      }

      // --->>> Add Hide/Show for Window Capture <<<---
      if (mainWin && mainWin.isVisible()) {
        console.log("[capture-window handler] Hiding main window.");
        mainWin.hide();
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      // --- End Hide ---

      const result = await captureService.captureWindow(windowId);
      console.log(
        "[IPC] capture-window: Result received from service:",
        JSON.stringify(result)
      );

      // --->>> ADD: Send result via 'capture-data' if successful <<<---
      if (
        result.success &&
        result.dataUrl &&
        mainWin &&
        !mainWin.isDestroyed()
      ) {
        console.log(
          "[IPC] capture-window: Sending successful result via 'capture-data' channel."
        );
        mainWin.webContents.send("capture-data", {
          success: true,
          dataUrl: result.dataUrl,
        });
      } else if (!result.success && mainWin && !mainWin.isDestroyed()) {
        // Optionally send failure message via capture-data if needed by UI
        console.log(
          "[IPC] capture-window: Sending failure result via 'capture-data' channel."
        );
        mainWin.webContents.send("capture-data", {
          success: false,
          message: result.message || "Window capture failed.",
        });
      }
      // --- End ADD ---

      return result; // Still return result for the invoke call (though App.tsx ignores it)
    } catch (error) {
      console.error("[IPC] Error in capture-window handler:", error); // <-- ADD LOG
      // Send error back via 'capture-data' as well
      if (mainWin && !mainWin.isDestroyed()) {
        console.log(
          "[IPC] capture-window: Sending error via 'capture-data' channel."
        );
        mainWin.webContents.send("capture-data", {
          success: false,
          message: error.message || "Failed to capture window",
        });
      }
      return {
        success: false,
        message: error.message || "Failed to capture window",
      };
    } finally {
      // --->>> Add Show Window in finally block <<<---
      if (mainWin && !mainWin.isDestroyed()) {
        console.log(
          "[capture-window handler] Showing main window after attempt."
        );
        mainWin.show();
        mainWin.focus();
        mainWin.moveTop(); // <<< ADDED: Bring to front
      }
      // --- End Show ---
    }
  });

  // --- Moved Hub IPC Handlers ---
  ipcMain.on("hide-menu-window", () => {
    console.log("IPC: Handling hide-menu-window"); // <-- ADD LOG
    menuWindow?.hide();
  });

  ipcMain.on("request-region-capture", () => {
    console.log("[index.ts] Received 'request-region-capture' from menu.");

    // Create main window if it doesn't exist or was destroyed
    if (!mainWindow || mainWindow.isDestroyed()) {
      console.log("[index.ts] Main window doesn't exist, creating new one.");
      createWindow();
    }

    // Use the mainWindow reference DIRECTLY from this file's scope
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log(
        "[index.ts] Found mainWindow, initiating region capture directly."
      );
      // --- Start Region Capture Logic (mimics the start of handle('capture', 'region')) ---
      // Prevent concurrent captures if one is already running
      if (captureWindow) {
        console.warn(
          "[request-region-capture] Capture already in progress, ignoring request."
        );
        menuWindow?.hide(); // Still hide menu
        return;
      }
      // Start the screenshot and capture window creation process asynchronously
      startRegionCaptureProcess(); // <-- ENSURE THIS IS THE CALL BEING MADE
      // --- End Region Capture Logic ---
    } else {
      console.error(
        "[index.ts] Could not find mainWindow or it was destroyed."
      );
    }

    // Hide the menu
    menuWindow?.hide();
  });

  ipcMain.on(
    "show-menu-window",
    (event, position?: { x: number; y: number }) => {
      console.log("IPC: Handling show-menu-window", position); // <-- ADD LOG
      if (menuWindow) {
        if (position) {
          const menuSize = menuWindow.getSize();
          const menuX = Math.round(position.x - menuSize[0] / 2);
          const menuY = Math.round(position.y - menuSize[1] / 2);
          menuWindow.setPosition(menuX, menuY);
        } else {
          // Default position if not provided (e.g., center screen)
          const primaryDisplay = screen.getPrimaryDisplay();
          const { width, height } = primaryDisplay.size;
          const menuSize = menuWindow.getSize();
          menuWindow.setPosition(
            Math.round((width - menuSize[0]) / 2),
            Math.round((height - menuSize[1]) / 2)
          );
        }
        menuWindow.show();
        menuWindow.focus();
      }
    }
  );

  ipcMain.on("trigger-mouse-enter", () => {
    console.log("IPC: Handling trigger-mouse-enter");
    if (menuWindow && !menuWindow.isVisible()) {
      console.log(
        "IPC: Mouse entered trigger zone - Menu is not visible, showing."
      );
      // Set position at the very top of the screen
      const newY = 0; // Position at the very top of the screen
      menuWindow.setPosition(menuTargetX, newY); // Position at top
      console.log(
        `Setting menu position (static X): X=${menuTargetX}, Y=${newY}`
      );
      menuWindow.show();
      menuWindow.focus();
    } else if (menuWindow) {
      // Also refocus menu when trigger is entered if menu is already visible
      menuWindow.focus();
      console.log(
        "IPC: Mouse entered trigger zone - Menu already visible, refocusing"
      );
    }
  });
  // --- End Moved Hub IPC Handlers ---

  // --- Application Service IPC Handlers ---
  ipcMain.handle("get-installed-applications", async () => {
    console.log("IPC: Handling get-installed-applications");
    try {
      const { ApplicationService } = await import(
        "./services/applicationService"
      );
      const appService = ApplicationService.getInstance();
      return await appService.getInstalledApplications();
    } catch (error) {
      console.error("Error getting installed applications:", error);
      return [];
    }
  });

  ipcMain.handle("add-custom-application", async (event, appData) => {
    console.log("IPC: Handling add-custom-application", appData);
    try {
      const { ApplicationService } = await import(
        "./services/applicationService"
      );
      const appService = ApplicationService.getInstance();
      return await appService.addCustomApplication(appData);
    } catch (error) {
      console.error("Error adding custom application:", error);
      throw error;
    }
  });

  ipcMain.on("remove-custom-application", async (event, appId: string) => {
    console.log("IPC: Handling remove-custom-application", appId);
    try {
      const { ApplicationService } = await import(
        "./services/applicationService"
      );
      const appService = ApplicationService.getInstance();
      appService.removeCustomApplication(appId);
    } catch (error) {
      console.error("Error removing custom application:", error);
    }
  });

  ipcMain.on("launch-application", async (event, appId: string) => {
    console.log("IPC: Handling launch-application", appId);
    try {
      const { ApplicationService } = await import(
        "./services/applicationService"
      );
      const appService = ApplicationService.getInstance();
      await appService.launchApplication(appId);
      console.log(`Successfully launched application: ${appId}`);
    } catch (error) {
      console.error("Error launching application:", error);
    }
  });

  ipcMain.handle("browse-for-application", async () => {
    console.log("IPC: Handling browse-for-application");
    try {
      const { ApplicationService } = await import(
        "./services/applicationService"
      );
      const appService = ApplicationService.getInstance();
      return await appService.browseForApplication();
    } catch (error) {
      console.error("Error browsing for application:", error);
      return null;
    }
  });
  // --- End Application Service IPC Handlers ---

  console.log("[index.ts] Registering IPC Handlers END"); // <-- ADD LOG
}

const createWindow = (): void => {
  console.log("[index.ts] createWindow START"); // <-- ADD LOG
  // Create the main application window.
  mainWindow = new BrowserWindow({
    // Assign to global variable
    height: 600, // Increased initial size
    width: 800, // Increased initial size
    // Removed frame: false, transparent: true, alwaysOnTop: true
    show: false, // <-- ADDED: Start hidden
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true, // Recommended security practice
      nodeIntegration: false, // Recommended security practice
    },
  });

  // and load the index.html of the app.
  console.log(
    `[index.ts] Loading main window URL: ${MAIN_WINDOW_WEBPACK_ENTRY}`
  ); // <-- ADD LOG
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Prevent window contents from being captured (Windows/macOS)
  if (process.platform === "win32" || process.platform === "darwin") {
    console.log("[index.ts] Enabling content protection for main window.");
    mainWindow.setContentProtection(true);
  }

  // Open DevTools automatically for the main window during development
  if (!app.isPackaged) {
    console.log("[index.ts] Opening DevTools for main window.");
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("closed", () => {
    console.log("[index.ts] Main window closed event."); // <-- ADD LOG
    mainWindow = null; // Dereference window object
  });
  console.log("[index.ts] createWindow END"); // <-- ADD LOG
};

// --- Moved Hub Window Creation Functions ---
const createMenuWindow = (): void => {
  console.log("[index.ts] Creating Hub Menu window...");
  menuWindow = new BrowserWindow({
    width: HUB_WIDTH,
    height: HUB_HEIGHT,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    skipTaskbar: true,
    show: false,
    webPreferences: {
      preload: HUB_MENU_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  menuWindow.loadURL(HUB_MENU_WINDOW_WEBPACK_ENTRY);
  // menuWindow.webContents.openDevTools({ mode: 'detach' });

  menuWindow.on("blur", () => {
    console.log("[HubMenu] Window blurred, hiding.");
    if (menuWindow && !menuWindow.isDestroyed()) {
      menuWindow.hide();
    }
  });

  menuWindow.on("closed", () => {
    console.log("[HubMenu] Window closed.");
    menuWindow = null;
  });
};

const showMenuCentered = () => {
  if (!menuWindow) return;

  const cursorPoint = screen.getCursorScreenPoint();
  const display = screen.getDisplayNearestPoint(cursorPoint);

  // Center the window horizontally on the cursor
  const x = Math.round(cursorPoint.x - HUB_WIDTH / 2);

  // Position the window higher up on the screen for compact initial appearance
  // This allows the menu to expand downward when more hexagons are added
  const topQuarterHeight = display.bounds.height * 0.25; // Top 25% of screen
  const y = Math.max(
    display.bounds.y + 50, // Minimum 50px from top of screen
    Math.min(cursorPoint.y - 100, display.bounds.y + topQuarterHeight) // Prefer cursor - 100px, but not lower than top quarter
  );

  // Ensure the window is within the display bounds
  const { width: displayWidth, height: displayHeight } = display.bounds;

  const finalX = Math.max(
    display.bounds.x,
    Math.min(x, display.bounds.x + displayWidth - HUB_WIDTH)
  );

  // Allow the menu to expand downward by ensuring it starts in the upper portion
  const finalY = Math.max(
    display.bounds.y + 30, // Minimum margin from screen top
    Math.min(y, display.bounds.y + displayHeight * 0.3) // Keep in upper 30% of screen
  );

  menuWindow.setPosition(finalX, finalY, false);
  menuWindow.show();
  menuWindow.focus();
};

const createTriggerWindow = (): void => {
  console.log("[index.ts] createTriggerWindow START"); // <-- ADD LOG
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth } = primaryDisplay.size;
  const triggerHeight = 3; // Minimal height - just enough for interaction
  const triggerWidth = 60; // Even shorter trigger line

  // Calculate the absolute path to the bundled preload script for the trigger
  // This depends on the 'name' given in the WebpackPlugin entry point config
  const preloadScriptPath = app.isPackaged
    ? path.join(
        process.resourcesPath,
        "app",
        ".webpack",
        "renderer",
        "hub_trigger_preload_only", // Matches name in forge.config.ts
        "preload.js"
      )
    : path.join(
        app.getAppPath(),
        ".webpack",
        "renderer",
        "hub_trigger_preload_only", // Matches name in forge.config.ts
        "preload.js"
      );
  console.log(`[index.ts] Using Trigger Preload Path: ${preloadScriptPath}`); // <-- ADD LOG

  // Verify preload script exists before creating window
  if (!fs.existsSync(preloadScriptPath)) {
    console.error(
      "[index.ts] FATAL: Trigger preload script not found at:",
      preloadScriptPath
    ); // <-- ADD LOG
    // Handle error appropriately - maybe skip trigger window creation
    return;
  }

  const triggerX = Math.round((screenWidth - triggerWidth) / 2); // Center the short trigger line
  const triggerY = 0; // Positioned at the very top of the screen

  triggerWindow = new BrowserWindow({
    x: triggerX,
    y: triggerY,
    width: triggerWidth,
    height: triggerHeight,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: true,
    show: true,
    webPreferences: {
      // Use the calculated absolute path to the bundled preload script
      preload: preloadScriptPath,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // --- Calculate the target X for the menu window ---
  // Needs to happen AFTER menuWindow is potentially created,
  // or be recalculated if menuWindow is created later.
  // Let's try calculating it here, assuming menuWindow exists or will soon.
  const calculateMenuTargetX = () => {
    console.log("[index.ts] Attempting to calculate menuTargetX..."); // <-- ADD LOG
    if (menuWindow) {
      const menuSize = menuWindow.getSize();
      console.log("[index.ts] Menu window size:", menuSize); // <-- ADD LOG
      const triggerCenterX = triggerX + triggerWidth / 2;
      menuTargetX = Math.round(triggerCenterX - menuSize[0] / 2);
      console.log(`[index.ts] Calculated static menuTargetX: ${menuTargetX}`); // <-- ADD LOG
    } else {
      console.warn(
        "[index.ts] Menu window not available yet to calculate menuTargetX."
      ); // <-- ADD LOG
      // Optionally retry later or set a default
      setTimeout(calculateMenuTargetX, 500); // Retry after 500ms
    }
  };
  // Initial calculation attempt
  calculateMenuTargetX();
  // --- End menuTargetX calculation ---

  // triggerWindow.setIgnoreMouseEvents(false); // <-- OLD: Blocks clicks
  triggerWindow.setIgnoreMouseEvents(true, { forward: true }); // <-- NEW: Allow click-through, forward mouse moves

  // Load the HTML file directly using its path
  const triggerHtmlPath = getAssetPath("src", "hub", "trigger.html");
  console.log(`[index.ts] Loading Trigger Window File: ${triggerHtmlPath}`); // <-- ADD LOG
  triggerWindow.loadFile(triggerHtmlPath);

  // Open DevTools for trigger window ONLY during development
  if (!app.isPackaged) {
    // Commenting out to prevent the second DevTools window
    // console.log("[index.ts] Opening DevTools for trigger window."); // <-- ADD LOG (if uncommenting)
    // triggerWindow.webContents.openDevTools({ mode: "detach" });
  }

  triggerWindow.on("closed", () => {
    console.log("[index.ts] Trigger window closed event."); // <-- ADD LOG
    triggerWindow = null;
  });
  console.log("[index.ts] createTriggerWindow END"); // <-- ADD LOG
};
// --- End Moved Hub Window Creation ---

// Function to close capture window and clean up state
const cleanupCapture = () => {
  console.log("[index.ts] cleanupCapture START"); // <-- ADD LOG
  if (captureWindow && !captureWindow.isDestroyed()) {
    console.log("[index.ts] Closing capture window."); // <-- ADD LOG
    captureWindow.close();
  }
  captureWindow = null;
  console.log("[index.ts] Set captureWindow to null."); // <-- ADDED LOG
  tempScreenshotDataUrl = null;
  // Ensure main window is visible again ONLY if it exists and isn't destroyed
  if (mainWindow && !mainWindow.isDestroyed()) {
    console.log("[index.ts] Showing main window after capture cleanup."); // <-- ADD LOG
    mainWindow.show();
  }
  console.log("[index.ts] cleanupCapture END"); // <-- ADD LOG
};

// --- Helper Function for Region Capture Initiation ---
async function startRegionCaptureProcess() {
  console.log("[index.ts] startRegionCaptureProcess START");
  if (!mainWindow || mainWindow.isDestroyed()) {
    console.error(
      "[index.ts] startRegionCaptureProcess: Main window is not available."
    );
    return;
  }

  // --->>> ADD Hide Main Window <<<---
  let wasMainWindowVisible = false;
  if (mainWindow.isVisible()) {
    console.log("[startRegionCaptureProcess] Hiding main window.");
    mainWindow.hide();
    wasMainWindowVisible = true;
    // Add a small delay
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  // --- End Hide ---

  const screenshotPromise = (async () => {
    console.log("[index.ts] Starting screenshot capture promise...");
    const primaryDisplay = screen.getPrimaryDisplay();
    const { width, height } = primaryDisplay.size;
    const scaleFactor = primaryDisplay.scaleFactor;
    const sources = await desktopCapturer.getSources({
      types: ["screen"],
      thumbnailSize: {
        width: width * scaleFactor,
        height: height * scaleFactor,
      },
    });
    const primarySource = sources.find(
      (source) => source.display_id?.toString() === primaryDisplay.id.toString()
    );
    if (!primarySource) {
      throw new Error("Primary display source not found for region capture.");
    }
    tempScreenshotDataUrl = primarySource.thumbnail.toDataURL();
    console.log("[index.ts] Screenshot captured for region selection.");
    return tempScreenshotDataUrl;
  })();

  // 2. Start Window Creation and Loading Promise
  const windowReadyPromise = new Promise<void>((resolve, reject) => {
    console.log("[index.ts] Starting capture window creation promise...");
    const primaryDisplay = screen.getPrimaryDisplay();
    const { width, height } = primaryDisplay.size;

    captureWindow = new BrowserWindow({
      x: primaryDisplay.bounds.x,
      y: primaryDisplay.bounds.y,
      width: width,
      height: height,
      frame: false,
      alwaysOnTop: true,
      skipTaskbar: true,
      autoHideMenuBar: true,
      show: false, // Start hidden
      webPreferences: {
        preload: CAPTURE_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });
    console.log("[index.ts] Capture window created for region selection.");

    captureWindow.webContents.once("did-finish-load", () => {
      console.log(
        "[index.ts] Capture window finished loading for region selection."
      );
      if (captureWindow && !captureWindow.isDestroyed()) {
        captureWindow.show();
        resolve();
      } else {
        console.error(
          "[index.ts] Capture window destroyed before load finished."
        );
        reject(new Error("Capture window destroyed before load finished."));
      }
    });

    const captureUrl = CAPTURE_WINDOW_WEBPACK_ENTRY;
    console.log(`[index.ts] Loading capture window URL: ${captureUrl}`);
    captureWindow.loadURL(captureUrl);
  });

  // Wait for both and send data
  try {
    console.log(
      "[index.ts] Waiting for screenshot and capture window ready..."
    );
    await Promise.all([screenshotPromise, windowReadyPromise]);
    console.log("[index.ts] Both screenshot and capture window ready.");

    if (
      captureWindow &&
      !captureWindow.isDestroyed() &&
      tempScreenshotDataUrl
    ) {
      console.log("[index.ts] Sending screenshot data to capture window...");
      captureWindow.webContents.send("screenshot-data", tempScreenshotDataUrl);
    } else {
      console.error(
        "[index.ts] Capture window or screenshot data missing after waiting."
      );
      cleanupCapture();
      throw new Error("Failed to prepare capture window or data.");
    }
  } catch (error) {
    console.error("[index.ts] Error during region capture initiation:", error);
    cleanupCapture(); // Clean up if initiation fails
    // Optionally notify the main window renderer?
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send("capture-data", {
        success: false,
        message: "Region capture failed to start.",
      });
      mainWindow.show(); // Show main window again on failure
    }
  }
  console.log("[index.ts] startRegionCaptureProcess END");
}
// --- End Helper Function ---

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
console.log("[index.ts] Setting up app.whenReady()..."); // <-- ADD LOG
app
  .whenReady()
  .then(() => {
    // --- Temporarily Simplified ---
    console.log(
      "[index.ts] App Ready event fired. Inside .then() - RESTORING FULL BLOCK" // <-- MODIFIED LOG
    ); // <-- MODIFIED LOG

    // *** Register handlers BEFORE creating any windows ***
    try {
      console.log("[index.ts] Calling registerIpcHandlers()...");
      registerIpcHandlers();
      console.log("[index.ts] registerIpcHandlers() completed successfully.");
    } catch (error) {
      console.error(
        "[index.ts] FATAL ERROR during registerIpcHandlers:",
        error
      );
      return;
    }

    // *** Create ALL windows ***
    try {
      console.log("[index.ts] Calling createWindow()...");
      createWindow(); // Main snipping tool window
      console.log("[index.ts] createWindow() completed successfully.");
    } catch (error) {
      console.error("[index.ts] FATAL ERROR during createWindow:", error);
      return;
    }

    console.log("[index.ts] Calling createMenuWindow()..."); // <-- RESTORED
    createMenuWindow(); // Hub menu window (initially hidden)
    console.log("[index.ts] Calling createTriggerWindow()..."); // <-- RESTORED
    createTriggerWindow(); // Hub trigger zone

    console.log("[index.ts] Setting up app.on('activate')...");
    app.on("activate", () => {
      console.log("[index.ts] App activate event fired.");
      if (BrowserWindow.getAllWindows().length === 0) {
        console.log("[index.ts] No windows open, recreating...");
        // Recreate main window and potentially hub windows if desired
        createWindow();
        // Consider if menu/trigger should also be recreated here
        if (!menuWindow) createMenuWindow();
        if (!triggerWindow) createTriggerWindow();
      }
    });
    console.log(
      "[index.ts] Finished app.whenReady().then() - FULL BLOCK RESTORED" // <-- MODIFIED LOG
    ); // <-- MODIFIED LOG
    // --- End Temporarily Simplified ---
  })
  .catch((error) => {
    // --- ADDED CATCH BLOCK ---
    console.error(
      "[index.ts] FATAL ERROR during app.whenReady() promise:",
      error
    );
    // --- END ADDED CATCH BLOCK ---
  });

// Handle window close events more selectively
// We want to keep the hub menu system running even when main window closes
console.log("[index.ts] Setting up app.on('window-all-closed')..."); // <-- ADD LOG
app.on("window-all-closed", () => {
  console.log("[index.ts] Window-all-closed event fired."); // <-- MODIFIED LOG

  // Check if we still have hub windows running
  const hasActiveHubWindows =
    (menuWindow && !menuWindow.isDestroyed()) ||
    (triggerWindow && !triggerWindow.isDestroyed());

  if (hasActiveHubWindows) {
    console.log("[index.ts] Hub windows still active, keeping app running.");
    // Don't quit if hub windows are still active
    return;
  }

  // Only quit if truly no windows are left and not on macOS
  if (process.platform !== "darwin") {
    console.log(
      "[index.ts] No active windows remaining, quitting application."
    );
    app.quit();
  } else {
    console.log(
      "[index.ts] Is darwin, not quitting application automatically."
    );
  }
});

// Ensure handlers are removed on quit (important for globalShortcut later)
console.log("[index.ts] Setting up app.on('will-quit')..."); // <-- ADD LOG
app.on("will-quit", () => {
  // Example: If we add global shortcuts, unregister them here
  // globalShortcut.unregisterAll();
  console.log("[index.ts] App will-quit event fired. Cleaning up..."); // <-- MODIFIED LOG
});

console.log("[index.ts] End of main process file."); // <-- ADD LOG

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
