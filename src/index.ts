import {
  app,
  BrowserWindow,
  ipcMain,
  desktopCapturer,
  screen,
  nativeImage,
} from "electron";
import path from "path"; // Import path module
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
// Declare the entry point for the capture window
declare const CAPTURE_WINDOW_WEBPACK_ENTRY: string;
declare const CAPTURE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

// Keep track of the main window globally (or pass it around)
let mainWindow: BrowserWindow | null = null;
// Temporary state for region capture
let captureWindow: BrowserWindow | null = null;
let tempScreenshotDataUrl: string | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    // Assign to global variable
    height: 250,
    width: 250,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Re-enable automatic DevTools opening for main window for debugging
  mainWindow.webContents.openDevTools();
};

// Function to close capture window and clean up state
const cleanupCapture = () => {
  if (captureWindow && !captureWindow.isDestroyed()) {
    captureWindow.close();
  }
  captureWindow = null;
  tempScreenshotDataUrl = null;
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.show(); // Ensure main window is visible again
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
  createWindow();

  // IPC handler for initiating capture (region part modified)
  ipcMain.handle("capture", async (event, type: string, options?: any) => {
    console.log(`Received capture request: ${type}`, options);

    // Prevent concurrent captures
    if (captureWindow) {
      return { success: false, message: "Capture already in progress" };
    }

    try {
      if (type === "fullscreen") {
        console.log("Handling fullscreen capture...");

        // Get primary display
        const primaryDisplay = screen.getPrimaryDisplay();
        const { width, height } = primaryDisplay.size;
        const scaleFactor = primaryDisplay.scaleFactor;

        // Get screen sources
        const sources = await desktopCapturer.getSources({
          types: ["screen"],
          thumbnailSize: {
            width: width * scaleFactor,
            height: height * scaleFactor,
          }, // Get full-res thumbnail
        });

        // Find the source corresponding to the primary display
        // Note: This matching might need adjustment on multi-monitor setups or specific OS
        const primarySource = sources.find(
          (source) =>
            source.display_id?.toString() === primaryDisplay.id.toString()
        );

        if (!primarySource) {
          throw new Error("Primary display source not found.");
        }

        // Get the image data as a Data URL
        const dataUrl = primarySource.thumbnail.toDataURL();

        console.log("Fullscreen capture successful.");
        return { success: true, dataUrl }; // Send data URL back
      } else if (type === "region") {
        console.log("Handling region capture...");
        if (!mainWindow)
          return { success: false, message: "Main window not available" };

        mainWindow.hide();
        // No need for delay here anymore if overlap works

        // --- Start Operations Concurrently ---

        // 1. Start Screenshot Capture Promise
        const screenshotPromise = (async () => {
          const primaryDisplay = screen.getPrimaryDisplay();
          const { width, height } = primaryDisplay.size;
          const scaleFactor = primaryDisplay.scaleFactor;
          const sources = await desktopCapturer.getSources({
            types: ["screen"],
            thumbnailSize: {
              width: width * scaleFactor,
              height: height * scaleFactor,
            },
          });
          const primarySource = sources.find(
            (source) =>
              source.display_id?.toString() === primaryDisplay.id.toString()
          );
          if (!primarySource) {
            throw new Error(
              "Primary display source not found for region capture."
            );
          }
          // Store screenshot temporarily (make sure tempScreenshotDataUrl is accessible)
          tempScreenshotDataUrl = primarySource.thumbnail.toDataURL();
          console.log("Screenshot captured.");
          return tempScreenshotDataUrl; // Return data URL or just signal completion
        })();

        // 2. Start Window Creation and Loading Promise
        const windowReadyPromise = new Promise<void>((resolve, reject) => {
          const primaryDisplay = screen.getPrimaryDisplay(); // Get display info again
          const { width, height } = primaryDisplay.size;

          // Create the capture window
          captureWindow = new BrowserWindow({
            x: primaryDisplay.bounds.x,
            y: primaryDisplay.bounds.y,
            width: width,
            height: height,
            frame: false,
            alwaysOnTop: true,
            skipTaskbar: true,
            autoHideMenuBar: true,
            show: false, // Start hidden, show when ready
            webPreferences: {
              preload: CAPTURE_WINDOW_PRELOAD_WEBPACK_ENTRY,
            },
          });
          console.log("Capture window created.");

          // Handle closed event during setup
          captureWindow.once("closed", () => {
            console.log("Capture window closed during setup.");
            reject(new Error("Capture window closed prematurely."));
            cleanupCapture();
          });

          // Resolve promise when content finishes loading
          captureWindow.webContents.once("did-finish-load", () => {
            console.log("Capture window finished loading.");
            if (captureWindow && !captureWindow.isDestroyed()) {
              captureWindow.show(); // Show the window now that it's loaded
              resolve(); // Signal that the window is ready
            } else {
              reject(
                new Error("Capture window destroyed before load finished.")
              );
            }
          });

          // Load the base capture UI URL
          const captureUrl = CAPTURE_WINDOW_WEBPACK_ENTRY;
          console.log(`Loading capture window URL: ${captureUrl}`);
          captureWindow.loadURL(captureUrl);

          // Open DevTools (optional, can be removed later)
          // Remove automatic DevTools opening for capture window
          // captureWindow.webContents.openDevTools();
        });

        // --- Wait for Both Operations ---
        console.log("Waiting for screenshot capture and window load...");
        await Promise.all([screenshotPromise, windowReadyPromise]);
        console.log("Both operations complete.");

        // --- Send Data to Ready Window ---
        if (
          captureWindow &&
          !captureWindow.isDestroyed() &&
          tempScreenshotDataUrl
        ) {
          console.log("Sending screenshot data via IPC...");
          captureWindow.webContents.send(
            "screenshot-data",
            tempScreenshotDataUrl
          );
        } else {
          // Should not happen if promises resolved, but handle defensively
          console.error("Window or screenshot data missing after waiting.");
          cleanupCapture(); // Clean up if something went wrong
          throw new Error("Failed to prepare capture window or data.");
        }

        // Return success for initiation, final result comes via 'capture-result'
        return { success: true, message: "Region capture window opened" };
      } else {
        console.warn(`Unknown capture type: ${type}`);
        return { success: false, message: "Unknown capture type" };
      }
    } catch (error) {
      console.error("Capture Initiation Error:", error);
      cleanupCapture(); // Clean up if initiation failed
      return {
        success: false,
        message: error.message || "An unknown capture error occurred",
      };
    }
  });

  // *** NEW: IPC listener for capture results from captureWindow ***
  ipcMain.on(
    "capture-result",
    async (event, result: { cancelled: boolean; bounds?: any }) => {
      console.log("Received capture result:", result);

      const storedScreenshotUrl = tempScreenshotDataUrl; // Copy before cleanup
      const mainWin = mainWindow; // Copy before cleanup

      cleanupCapture(); // Close window, clear state, show main window

      if (
        result.cancelled ||
        !result.bounds ||
        !storedScreenshotUrl ||
        !mainWin
      ) {
        console.log("Region capture cancelled or failed.");
        return; // Nothing more to do
      }

      try {
        // Get scale factor for accurate cropping
        const primaryDisplay = screen.getPrimaryDisplay();
        const scaleFactor = primaryDisplay.scaleFactor;

        // Adjust bounds for scale factor
        const scaledBounds = {
          x: Math.floor(result.bounds.x * scaleFactor),
          y: Math.floor(result.bounds.y * scaleFactor),
          width: Math.floor(result.bounds.width * scaleFactor),
          height: Math.floor(result.bounds.height * scaleFactor),
        };

        // Ensure bounds are within image dimensions (basic check)
        const image = nativeImage.createFromDataURL(storedScreenshotUrl);
        const imageSize = image.getSize();
        if (scaledBounds.x < 0) scaledBounds.x = 0;
        if (scaledBounds.y < 0) scaledBounds.y = 0;
        if (scaledBounds.x + scaledBounds.width > imageSize.width)
          scaledBounds.width = imageSize.width - scaledBounds.x;
        if (scaledBounds.y + scaledBounds.height > imageSize.height)
          scaledBounds.height = imageSize.height - scaledBounds.y;
        if (scaledBounds.width <= 0 || scaledBounds.height <= 0) {
          throw new Error("Calculated crop bounds are invalid.");
        }

        // Crop the image
        const croppedImage = image.crop(scaledBounds);
        const croppedDataUrl = croppedImage.toDataURL();

        console.log(
          "Region capture successful, sending cropped image to main window."
        );

        // Send the final cropped image back to the main window renderer
        mainWin.webContents.send("capture-data", {
          success: true,
          dataUrl: croppedDataUrl,
        });
      } catch (error) {
        console.error("Error processing region capture result:", error);
        // Optionally send an error message back to the main window
        if (mainWin && !mainWin.isDestroyed()) {
          mainWin.webContents.send("capture-data", {
            success: false,
            message: error.message,
          });
        }
      }
    }
  );

  // Listener for quit request from renderer
  ipcMain.on("quit-app", () => {
    console.log("Quit request received from renderer.");
    app.quit();
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
